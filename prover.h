#ifndef _PROVER_H
#define _PROVER_H
#include "defs.h"
#include <vector>
#include <string>
#include <algorithm>
/**One view of proofs stipulates that a proof is an array of well formed propositions generated by
*various inference rules leading to some concluding formula in this sense a prover is a class containing
*an array/vector of propositions, bookkeeping metadata and methods for manipulating them. The particular
*method of proof being implemented is proof by contradiction
*/
class Prover
{
    /**The count of premises(propositions) contained in the proof*/
    int _premcount;
    /**The highest level of assumption made in the proof currently assumptions nest until they reach contradictions
    *In this manner _highestasm is incremented and decremented as needed until the proof is complete. By default the
    *highest assumption is one since in proof by contradiction we assume the negation of the conclusion hence why
    *a proof ends when all assumptions have been contradicted
    */
    int _highestasm;
    /**A vector containing pointers to the premises of the proof*/
    vector<shared_ptr<BoolExp>> _premi;
    /**Each formula in the proof needs to be justified every justification is stored as a string in the _reasons vector*/
    vector<string> 	_reasons;

    /**Contains the typeinfo for the propositions in parallel to _premi*/
    vector<PropType> _ptypes;

    //in addition to program logic these are used for printing in the correct format
    /**the level of nesting for each premise(proposition) is stored in _assum which is in parallel to _premi -1 is used
    *to specify when a line is in a level of nesting that has been proven contradictory contradicted lines are nested behind
    *'['s blocks to show they cannot be used or inferred from since they come from contradicted information
    */
    vector<int> _assum;
    /**the level of nesting for the blocked formulas is used for printing to show a blow by blow of each assumption and contradiction
    *in the output proof
    */
    vector<int> _blocked;
    /**Starred formulas are formulas which cannot be inferred from any more due to already being used in an inference
    *this is necessary to keep us from constantly inferring the same thing in a big loop generally after an inference rule
    *is applied formulas are starred off to show they cannot be used for further inference this is show as asterisks to the
    *right of each line number
    */
    vector<int> _starred;

    //These versions match a well formed formula anywhere in the proof including contradicted ones
    /**returns the line number of the string input if it exists anywhere in the proof return 0 if not this may need
    *to be changed if bugs/errors pop up
    *	@param input the string to search for
    *	@return returns the index of the matching string or 0 if no match
    */
    int MatchString(string input);
    /**returns the line number of the negation of the string input if it exists anywhere in the proof return 0 if not this may need
    *to be changed if bugs/errors pop up
    *	@param input the string to search for
    *	@return returns the index of the matching string or 0 if no match
    */
    int MatchNegation(string input);

    /**returns the line number of the string input if it exists anywhere unblocked off in the proof return 0 if not this may need
    *to be changed if bugs/errors pop up
    *	@param input the string to search for
    *	@return returns the index of the matching string or 0 if no match
    */
    int MatchStringUB(string input);
    /**returns the line number of the negation of the string input if it exists anywhere unblocked off in the proof return 0 if not this may need
    *to be changed if bugs/errors pop up
    *	@param input the string to search for
    *	@return returns the index of the matching string or 0 if no match
    */
    int MatchNegationUB(string input);

    /**attempt to apply the inference rules for OrExp's to the formula at index i
    *	@param i the formula in the proof at line i
    */
    void OrInference(int i);
    /**attempt to apply the inference rules for AndExp's to the formula at index i
    *	@param i the formula in the proof at line i
    */
    void AndInference(int i);
    /**attempt to apply the inference rules for CondExp's to the formula at index i
    *	@param i the formula in the proof at line i
    */
    void CondInference(int i);
    /**attempt to apply the inference rules for negated NotExp's to the formula at index i
    *	@param i the formula in the proof at line i
    */
    void NotNotInference(int i);
    /**attempt to apply the inference rules for negated OrExp's to the formula at index i
    *	@param i the formula in the proof at line i
    */
    void NotOrInference(int i);
    /**attempt to apply the inference rules for negated AndExp's to the formula at index i
    *	@param i the formula in the proof at line i
    */
    void NotAndInference(int i);
    /**attempt to apply the inference rules for negated CondExp's to the formula at index i
    *	@param i the formula in the proof at line i
    */
    void NotCondInference(int i);
    //assumption testing inference functions
    /**try to make an assumption based off of the formula at index i if it is a negated AndExp
    *	@param i the formula in the proof at line i
    *	@return returns true if an assumption is made returns false if an assumption is not made
    */
    void UnivInference(int i);
    void NotUnivInference(int i);
    void ExistInference(int i);
    void NotExistInference(int i);

    bool NotAndAsm(int i);
    /**try to make an assumption based off of the formula at index i if it is a negated OrExp
    *	@param i the formula in the proof at line i
    *	@return returns true if an assumption is made returns false if an assumption is not made
    */
    bool OrAsm(int i);
    /**try to make an assumption based off of the formula at index i if it is a negated CondExp
    *	@param i the formula in the proof at line i
    *	@return returns true if an assumption is made returns false if an assumption is not made
    */
    bool CondAsm(int i);

    /**Helper function to traverse a BoolExp in the proof every VarExp will be added to the vector
    *	@param vec the vector to receive variables
    *	@param boolexp the BoolExp being analyzed
    */
    void Traverse(vector<string>& vec, shared_ptr<BoolExp> boolexp);
public:
    /**The prover constructor init _prem to 0 and _highestasm to 1*/
    Prover();
    /**The prover destructor*/
    ~Prover();

    /**add the premise exp of type p because of reason
    *	@param exp the expression to add to the proof
    *	@param p the type of expression being added
    *	@param reason the reason for adding the expression
    */
    void AddPremise(shared_ptr<BoolExp> exp, PropType p, string reason);

    /**attempt to make an inference off of the formula at index i*/
    void Infer(const int i);
    /**scan the whole proof and attemp to make a single assumption
    *	@return returns true if an assumption is made returns false if no assumption is made
    */
    bool MakeAssumption();
    /**scan the whole proof attempt to find at least one contradiction if one is found
    *block off all formulas at matching assumption levels
    *	@return returns true if a contradiction was found returns false if a contradiction is not found
    */
    bool FindContradiction();

    /**print the current state of the proof include all assumption starred blocked info and reasons*/
    void PrintPremises() const;
    /**return the string form of the premise at index i
    *	@param i the index of the formula being referred to
    *	@return returns the string at index i
    */
    string PremiseName(int i) const;
    /**evaluate the premise at index i given the input Context map
    *	@param i the index of the formula to be evaluated
    *	@param context the context mapping variables to boolean values
    *	@return returns the evaluation of the formula at index i under the given context
    */
    bool Evaluate(int i, vector<tuple<string,string,bool>>,vector<string>,vector<string>) const;
    bool TestEvaluate(int i, vector<tuple<string,string,bool>>&,vector<string>&,vector<string>&) const;
    void CollectSubjects(vector<string>&) const;
    /**return the count of premises in the proof
    *	@return returns how many premises in the proof
    */
    int PremiseCount() const;
    /**return how many formulas are starred in the proof
    *	@return returns the count of formulas that have been starred thus far in the proof
    */
    int starredCount() const;
    /**returns the current highest assumption level in the proof
    *	@param returns the highest assumption level so far in the proof
    */
    int HighestAssumption() const;

    /**Assigns boolean values by formula within the proof from 0 to n and within each formula from left to right
    *	@param context the context containing the formulas receiving values
    */
    //void AssignByFormula(Context& context);
};
#endif
